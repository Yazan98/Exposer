{"version":3,"file":"kotlin-test-nodejs-runner.js","sources":["../src/utils.ts","../src/KotlinTestTeamCityConsoleAdapter.ts","../src/CliArgsParser.ts","../src/KotlinTestsFilter.ts","../src/teamcity-format.js","../src/TeamCityMessagesFlow.ts","../nodejs.ts","../src/Adapter.ts","../src/CliFiltertingConfiguration.ts"],"sourcesContent":["/**\n * From teamcity-service-messages.\n * Copyright 2013 Aaron Forsander\n */\nexport function newFlowId(): number {\n    return Math.floor(Math.random() * (1e10 - 1e6 + 1)) + 1e6;\n}\n\n/**\n * From teamcity-service-messages.\n * Copyright 2013 Aaron Forsander\n */\nexport function dateTimeWithoutTimeZone(): string {\n    // TeamCity not fully support ISO 8601 (see TW-36173) so we need to cut off 'Z' at the end.\n    return new Date().toISOString().slice(0, -1);\n}\n\n/**\n * From lodash.\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n */\nexport function startsWith(string: string, target: string) {\n    return string.slice(0, target.length) == target;\n}\n\n/**\n * From lodash.\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n */\nexport function trim(str: string): string {\n    return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n}\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * From lodash.\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n */\nexport function escapeRegExp(string: string) {\n    return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n}\n\nexport function pushIfNotNull<T>(list: T[], value: T) {\n    if (value !== null) list.push(value)\n}\n\nexport function flatMap<T>(arr: T[], f: (item: T) => T[]): T[] {\n    const result: T[] = [];\n    arr.forEach(item => {\n        f(item).forEach(x => {\n            result.push(x)\n        })\n    });\n    return result;\n}\n\nexport function println(message ?: string) {\n    console.log(message)\n}","import {KotlinTestRunner} from \"./KotlinTestRunner\";\nimport {TeamCityMessageData, TeamCityMessagesFlow} from \"./TeamCityMessagesFlow\";\nimport {format} from \"util\";\n\n// don't use enum as it is not minified by uglify\nexport type IgnoredTestSuitesReporting\n    = \"skip\" | \"reportAsIgnoredTest\" | \"reportAllInnerTestsAsIgnored\"\nexport const IgnoredTestSuitesReporting: { [key: string]: IgnoredTestSuitesReporting } = {\n    skip: \"skip\",\n    reportAsIgnoredTest: \"reportAsIgnoredTest\",\n    reportAllInnerTestsAsIgnored: \"reportAllInnerTestsAsIgnored\"\n};\n\n// to reduce minified code size\nfunction withName(name: string, data?: TeamCityMessageData): TeamCityMessageData {\n    data = data || {};\n    data[\"name\"] = name;\n    return data\n}\n\nexport function runWithTeamCityConsoleAdapter(\n    runner: KotlinTestRunner,\n    teamCity: TeamCityMessagesFlow\n): KotlinTestRunner {\n    return {\n        suite: function (name: string, isIgnored: boolean, fn: () => void) {\n            runner.suite(name, isIgnored, fn)\n        },\n        test: function (name: string, isIgnored: boolean, fn: () => void) {\n            let revertLogMethods: CallableFunction[] = [];\n\n            runner.test(name, isIgnored, () => {\n                const log = (type: string) => function (message?: any, ...optionalParams: any[]) {\n                    teamCity.sendMessage(\n                        \"testStdOut\",\n                        withName(\n                            name,\n                            {\n                                \"out\": `[${type}] ${format(message, ...optionalParams)}\\n`\n                            }\n                        )\n                    )\n                };\n\n                const logMethods = ['log', 'info', 'warn', 'error', 'debug'];\n\n                const globalConsole = console as unknown as {\n                    [method: string]: (message?: any, ...optionalParams: any[]) => void\n                };\n\n                revertLogMethods = logMethods\n                    .map(method => {\n                        const realMethod = globalConsole[method];\n                        globalConsole[method] = log(method);\n                        return () => globalConsole[method] = realMethod\n                    });\n                try {\n                    return fn();\n                } catch (e) {\n                    throw e;\n                } finally {\n                    revertLogMethods.forEach(revert => revert());\n                }\n            });\n        }\n    }\n}","import {println, startsWith} from \"./utils\";\nimport {IgnoredTestSuitesReporting} from \"./KotlinTestTeamCityConsoleAdapter\";\n\nexport type CliDescription = {\n    version: string,\n    bin: string,\n    description: string,\n    usage: string,\n    args: {\n        [k: string]: CliArgDescription,\n    },\n    freeArgsTitle: string | null\n}\n\nexport type CliArgValues = {\n    [k: string]: string[] | string,\n    free: string[]\n}\n\nexport type CliArgDescription = {\n    keys: string[],\n    help: string,\n    values?: string[],\n    valuesHelp?: string[],\n    default?: string,\n    single?: true\n}\n\nexport class CliArgsParser {\n    constructor(private description: CliDescription) {\n    }\n\n    printUsage() {\n        const description = this.description;\n\n        println(`${description.bin} v${description.version} - ${description.description}`);\n        println();\n        println(`Usage: ${description.bin} ${description.usage}`);\n        println();\n        for (let key in description.args) {\n            const data = description.args[key];\n            println('  ' + data.keys.join(', '));\n            const indent = '    ';\n            println(`${indent}${data.help}`);\n            if (data.values && data.valuesHelp) {\n                println(`${indent}Possible values:`);\n                for (let i = 0; i < data.values.length; i++) {\n                    const value = data.values[i];\n                    const help = data.valuesHelp[i];\n                    println(`${indent} - \"${value}\": ${help}`)\n                }\n            }\n            if (data.default) println(`${indent}By default: ${data.default}`);\n            println('')\n        }\n    }\n\n    badArgsExit(message: string) {\n        println(message);\n        println();\n        this.printUsage();\n        process.exit(1)\n    }\n\n    parse(args: string[]): CliArgValues {\n        const description = this.description;\n\n        const result: CliArgValues = {\n            free: []\n        };\n        for (let key in description.args) {\n            if (!description.args[key].single) {\n                result[key] = [];\n            }\n        }\n\n        // process all arguments from left to right\n        args: while (args.length != 0) {\n            const arg = args.shift() as string;\n\n            if (startsWith(arg, '--')) {\n                for (let argName in description.args) {\n                    const argDescription = description.args[argName];\n                    if (argDescription.keys.indexOf(arg) != -1) {\n                        if (args.length == 0) {\n                            this.badArgsExit(\"Missed value after option \" + arg);\n                        }\n\n                        const value = args.shift() as string;\n                        if (argDescription.values && argDescription.values.indexOf(value) == -1) {\n                            this.badArgsExit(\"Unsupported value for option \" + arg);\n                        }\n\n                        if (argDescription.single) {\n                            result[argName] = value;\n                        } else {\n                            (result[argName] as string[]).push(value);\n                        }\n\n                        continue args;\n                    }\n                }\n            } else {\n                result.free.push(arg)\n            }\n        }\n\n        if (description.freeArgsTitle && result.free.length == 0) {\n            this.badArgsExit(`At least one ${description.freeArgsTitle} should be provided`)\n        }\n\n        return result\n    }\n}\n\nexport function getDefaultCliDescription(): CliDescription {\n    return {\n        version: VERSION,\n        bin: BIN,\n        description: DESCRIPTION,\n        usage: \"[-t --tests] [-e --exclude] <module_name1>, <module_name2>, ..\",\n        args: {\n            include: {\n                keys: ['--tests', '--include'],\n                help: \"Tests to include. Example: MySuite.test1,MySuite.MySubSuite.*,*unix*,!*windows*\",\n                default: \"*\"\n\n            },\n            exclude: {\n                keys: ['--exclude'],\n                help: \"Tests to exclude. Example: MySuite.test1,MySuite.MySubSuite.*,*unix*\"\n            },\n            ignoredTestSuites: {\n                keys: ['--ignoredTestSuites'],\n                help: \"How to deal with ignored test suites\",\n                single: true,\n                values: [\n                    IgnoredTestSuitesReporting.skip,\n                    IgnoredTestSuitesReporting.reportAsIgnoredTest,\n                    IgnoredTestSuitesReporting.reportAllInnerTestsAsIgnored\n                ],\n                valuesHelp: [\n                    \"don't report ignored test suites\",\n                    \"useful to speedup large ignored test suites\",\n                    \"will cause visiting all inner tests\",\n                ],\n                default: IgnoredTestSuitesReporting.reportAllInnerTestsAsIgnored\n            }\n        },\n        freeArgsTitle: null\n    };\n}\n","import {escapeRegExp, startsWith, trim} from \"./utils\";\nimport {KotlinTestRunner} from \"./KotlinTestRunner\";\n\nexport interface KotlinTestsFilter {\n    mayContainTestsFromSuite(fqn: string): boolean;\n\n    containsTest(fqn: string): boolean;\n}\n\nexport function runWithFilter(\n    runner: KotlinTestRunner,\n    filter: KotlinTestsFilter,\n): KotlinTestRunner {\n    let path: string[] = [];\n\n    function pathString() {\n        // skip root\n        if (!path[0]) {\n            return path.slice(1).join('.')\n        } else {\n            return path.join('.')\n        }\n    }\n\n    return {\n        suite: function (name: string, isIgnored: boolean, fn: () => void) {\n            path.push(name);\n\n            try {\n                if (path.length > 1 && !filter.mayContainTestsFromSuite(pathString())) return;\n\n                runner.suite(name, isIgnored, fn);\n            } finally {\n                path.pop()\n            }\n        },\n\n        test: function (name: string, isIgnored: boolean, fn: () => void) {\n            path.push(name);\n\n            try {\n                if (!filter.containsTest(pathString())) return;\n\n                runner.test(name, isIgnored, fn);\n            } finally {\n                path.pop()\n            }\n        }\n    };\n}\n\nexport function newKotlinTestsFilter(wildcard: string | null): KotlinTestsFilter | null {\n    if (wildcard == null) return null;\n    wildcard = trim(wildcard);\n    wildcard = wildcard.replace(/\\*+/, '*'); // ** => *\n    if (wildcard.length == 0) return null;\n    else if (wildcard == '*') return allTest;\n    else if (wildcard.indexOf('*') == -1) return new ExactFilter(wildcard);\n    else if (startsWith(wildcard, '*')) return new RegExpKotlinTestsFilter(wildcard);\n    else {\n        // optimize for cases like \"Something*\", \"Something*a*b\" and so on.\n        // by adding explicit prefix matcher to not visit unneeded suites\n        // (RegExpKotlinTestsFilter doesn't support suites matching)\n        const [prefix, rest] = wildcard.split('*', 2);\n        return new StartsWithFilter(prefix, rest ? new RegExpKotlinTestsFilter(wildcard) : null)\n    }\n}\n\nexport const allTest = new class implements KotlinTestsFilter {\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return true;\n    }\n\n    containsTest(fqn: string): boolean {\n        return true;\n    }\n};\n\nexport class StartsWithFilter implements KotlinTestsFilter {\n    constructor(\n        public readonly prefix: string,\n        public readonly filter: RegExpKotlinTestsFilter | null\n    ) {\n    }\n\n    isPrefixMatched(fqn: string): boolean {\n        return startsWith(fqn + \".\", this.prefix);\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return this.isPrefixMatched(fqn);\n    }\n\n    containsAllTestsFromSuite(fqn: string): boolean {\n        return this.filter == null && this.isPrefixMatched(fqn);\n    }\n\n    containsTest(fqn: string): boolean {\n        return startsWith(fqn, this.prefix)\n            && (this.filter == null || this.filter.containsTest(fqn));\n    }\n}\n\nexport class ExactFilter implements KotlinTestsFilter {\n    constructor(public fqn: string) {\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return startsWith(this.fqn, fqn);\n    }\n\n    containsTest(fqn: string): boolean {\n        return fqn === this.fqn;\n    }\n}\n\nexport class RegExpKotlinTestsFilter implements KotlinTestsFilter {\n    public readonly regexp: RegExp;\n\n    constructor(wildcard: string) {\n        this.regexp = RegExp(\"^\" + wildcard\n            .split('*')\n            .map(it => escapeRegExp(it))\n            .join('.*') + \"$\"\n        );\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return true\n    }\n\n    containsTest(fqn: string): boolean {\n        return this.regexp!.test(fqn)\n    }\n\n    toString(): string {\n        return this.regexp.toString()\n    }\n}\n\nexport class CompositeTestFilter implements KotlinTestsFilter {\n    private readonly excludePrefix: StartsWithFilter[] = [];\n\n    constructor(\n        public include: KotlinTestsFilter[],\n        public exclude: KotlinTestsFilter[]\n    ) {\n        this.exclude.forEach(it => {\n            if (it instanceof StartsWithFilter && it.filter == null)\n                this.excludePrefix.push(it)\n        })\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        for (const excl of this.excludePrefix) {\n            if (excl.containsAllTestsFromSuite(fqn)) return false\n        }\n        for (const incl of this.include) {\n            if (incl.mayContainTestsFromSuite(fqn)) return true\n        }\n        return false;\n    }\n\n    containsTest(fqn: string): boolean {\n        for (const excl of this.exclude) {\n            if (excl.containsTest(fqn)) return false\n        }\n        for (const incl of this.include) {\n            if (incl.containsTest(fqn)) return true\n        }\n        return false\n    }\n}","/**\n * From mocha-teamcity-reporter\n * The MIT License\n * Copyright (c) 2016 Jamie Sherriff\n */\nexport const TEST_IGNORED = `##teamcity[testIgnored name='%s' message='%s' flowId='%s']`;\nexport const SUITE_START = `##teamcity[testSuiteStarted name='%s' flowId='%s']`;\nexport const SUITE_END = `##teamcity[testSuiteFinished name='%s' duration='%s' flowId='%s']`;\nexport const SUITE_END_NO_DURATION = `##teamcity[testSuiteFinished name='%s' flowId='%s']`;\nexport const TEST_START = `##teamcity[testStarted name='%s' captureStandardOutput='true' flowId='%s']`;\nexport const TEST_FAILED = `##teamcity[testFailed name='%s' message='%s' details='%s' captureStandardOutput='true' flowId='%s']`;\nexport const TEST_FAILED_COMPARISON = `##teamcity[testFailed type='comparisonFailure' name='%s' message='%s' \\\ndetails='%s' captureStandardOutput='true' actual='%s' expected='%s' flowId='%s']`;\nexport const TEST_END = `##teamcity[testFinished name='%s' duration='%s' flowId='%s']`;\nexport const TEST_END_NO_DURATION = `##teamcity[testFinished name='%s' flowId='%s']`;\nexport const BLOCK_OPENED = `##teamcity[blockOpened name='%s' flowId='%s']`\nexport const BLOCK_CLOSED = `##teamcity[blockClosed name='%s' flowId='%s']`\n\n/**\n * from teamcity-service-messages\n * Copyright (c) 2013 Aaron Forsander\n *\n * Escape string for TeamCity output.\n * @see https://confluence.jetbrains.com/display/TCD65/Build+Script+Interaction+with+TeamCity#BuildScriptInteractionwithTeamCity-servMsgsServiceMessages\n */\n\nconst util = require('util');\n\nexport function tcEscape(str) {\n    if (!str) {\n        return '';\n    }\n\n    return str\n        .toString()\n        .replace(/\\x1B.*?m/g, '') // eslint-disable-line no-control-regex\n        .replace(/\\|/g, '||')\n        .replace(/\\n/g, '|n')\n        .replace(/\\r/g, '|r')\n        .replace(/\\[/g, '|[')\n        .replace(/\\]/g, '|]')\n        .replace(/\\u0085/g, '|x') // next line\n        .replace(/\\u2028/g, '|l') // line separator\n        .replace(/\\u2029/g, '|p') // paragraph separator\n        .replace(/'/g, '|\\'');\n}\n\nexport function formatMessage() {\n    let formattedArguments = [];\n    const args = Array.prototype.slice.call(arguments, 0);\n    // Format all arguments for TC display (it escapes using the pipe char).\n    let tcMessage = args.shift();\n    args.forEach((param) => {\n        formattedArguments.push(tcEscape(param));\n    });\n    formattedArguments.unshift(tcMessage);\n    return util.format.apply(util, formattedArguments);\n}","import {dateTimeWithoutTimeZone, newFlowId} from \"./utils\"\nimport {tcEscape} from \"./teamcity-format\";\n\nexport type TeamCityMessageData = { [key: string]: any }\n\nexport class TeamCityMessagesFlow {\n    public readonly id: number;\n\n    constructor(id: number | null, private readonly send: (payload: string) => void) {\n        this.id = id || newFlowId()\n    }\n\n    sendMessage(type: string, args: TeamCityMessageData) {\n        args['flowId'] = this.id;\n        args['timestamp'] = dateTimeWithoutTimeZone();\n\n        const serializedArgs = Object\n            .keys(args)\n            .map((key) => `${key}='${tcEscape(args[key])}'`)\n            .join(' ');\n\n        this.send(`##teamcity[${type} ${serializedArgs}]`)\n    }\n}","import {CliArgsParser, getDefaultCliDescription} from \"./src/CliArgsParser\";\nimport {runWithFilteringAndConsoleAdapters} from \"./src/Adapter\";\n\nconst kotlin_test = require('kotlin-test');\n\nconst parser = new CliArgsParser(getDefaultCliDescription());\nconst untypedArgs = parser.parse(process.argv);\n\nconst initialAdapter = kotlin_test.kotlin.test.detectAdapter_8be2vx$();\nkotlin_test.setAdapter(runWithFilteringAndConsoleAdapters(initialAdapter, untypedArgs));","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport {CliArgValues} from \"./CliArgsParser\";\nimport {KotlinTestRunner} from \"./KotlinTestRunner\";\nimport {configureFiltering} from \"./CliFiltertingConfiguration\";\nimport {runWithTeamCityConsoleAdapter} from \"./KotlinTestTeamCityConsoleAdapter\";\nimport {TeamCityMessagesFlow} from \"./TeamCityMessagesFlow\";\n\nexport function runWithFilteringAndConsoleAdapters(\n    initialAdapter: KotlinTestRunner,\n    cliArgsValue: CliArgValues\n): KotlinTestRunner {\n    const realConsoleLog = console.log;\n    const teamCity = new TeamCityMessagesFlow(null, (payload) => realConsoleLog(payload));\n    return runWithTeamCityConsoleAdapter(\n        runWithFilteringAdapter(\n            initialAdapter,\n            cliArgsValue\n        ),\n        teamCity\n    )\n}\n\nexport function runWithFilteringAdapter(\n    initialAdapter: KotlinTestRunner,\n    cliArgsValue: CliArgValues\n): KotlinTestRunner {\n    const args = {\n        include: cliArgsValue.include as string[],\n        exclude: cliArgsValue.exclude as string[],\n    };\n\n    let runner: KotlinTestRunner = initialAdapter;\n    runner = configureFiltering(runner, args.include, args.exclude);\n\n    return runner;\n}","import {KotlinTestRunner} from \"./KotlinTestRunner\";\nimport {\n    allTest,\n    CompositeTestFilter,\n    KotlinTestsFilter,\n    newKotlinTestsFilter,\n    runWithFilter\n} from \"./KotlinTestsFilter\";\nimport {flatMap, println, pushIfNotNull} from \"./utils\";\n\nexport function configureFiltering(\n    runner: KotlinTestRunner,\n    includeWildcards: string[],\n    excludeWildcards: string[]\n): KotlinTestRunner {\n    const include: KotlinTestsFilter[] = [];\n    const exclude: KotlinTestsFilter[] = [];\n\n    function collectWildcards(\n        value: string[],\n        positive: KotlinTestsFilter[],\n        negative: KotlinTestsFilter[]\n    ) {\n        flatMap(value, (t: string) => t.split(','))\n            .map(t => {\n                if (t.length && t[0] == '!') {\n                    pushIfNotNull(negative, newKotlinTestsFilter(t.substring(1)))\n                } else {\n                    pushIfNotNull(positive, newKotlinTestsFilter(t))\n                }\n            })\n    }\n\n    collectWildcards(includeWildcards, include, exclude);\n    collectWildcards(excludeWildcards, exclude, include);\n\n    if (include.length == 0 && exclude.length == 0) {\n        return runner\n    } else {\n        if (include.length == 0) {\n            include.push(allTest)\n        }\n\n        const filter = new CompositeTestFilter(include, exclude);\n\n        if (DEBUG) {\n            println(filter.toString());\n        }\n\n        return runWithFilter(runner, filter)\n    }\n}\n"],"names":["startsWith","string","target","slice","length","reRegExpChar","reHasRegExpChar","RegExp","source","pushIfNotNull","list","value","push","println","message","console","log","IgnoredTestSuitesReporting","skip","reportAsIgnoredTest","reportAllInnerTestsAsIgnored","withName","name","data","runWithTeamCityConsoleAdapter","runner","teamCity","suite","isIgnored","fn","test","revertLogMethods","globalConsole","map","method","type","realMethod","_i","optionalParams","sendMessage","out","format","e","forEach","revert","description","this","CliArgsParser","key","bin","version","usage","args","keys","join","help","values","valuesHelp","indent","i","default","printUsage","process","exit","result","free","single","arg","shift","argName","argDescription","indexOf","badArgsExit","freeArgsTitle","newKotlinTestsFilter","wildcard","replace","allTest","ExactFilter","RegExpKotlinTestsFilter","_a","prefix","rest","StartsWithFilter","class_1","fqn","filter","isPrefixMatched","containsTest","regexp","split","it","toString","include","exclude","_this","excludePrefix","CompositeTestFilter","containsAllTestsFromSuite","_c","_b","mayContainTestsFromSuite","require","id","send","Math","floor","random","TeamCityMessagesFlow","Date","toISOString","serializedArgs","Object","str","kotlin_test","untypedArgs","VERSION","BIN","DESCRIPTION","ignoredTestSuites","parse","argv","initialAdapter","kotlin","detectAdapter_8be2vx$","setAdapter","cliArgsValue","realConsoleLog","payload","includeWildcards","excludeWildcards","collectWildcards","positive","negative","arr","f","t","item","x","substring","path","pathString","pop","runWithFilter","configureFiltering","runWithFilteringAdapter","runWithFilteringAndConsoleAdapters"],"mappings":"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"}